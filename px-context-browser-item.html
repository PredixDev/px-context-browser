<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-context-browser-actions.html"/>
<link rel="import" href="css/px-context-browser-item-styles.html"/>

<dom-module id="px-context-browser-item">
  <template>
    <style include="px-context-browser-item-styles"></style>

    <template is="dom-if" if="[[!styleAsFavorite]]">
      <section class="context-browser-item" asset-action="activate">
        <div class="context-browser-label regular">
          [[label]]
        </div>
        <div class="actions">
          <template is="dom-if" if="[[canFavorite]]">
            <px-context-browser-action-favorite class="action" active$="{{favorited}}" asset-action="favorite"></px-context-browser-action-favorite>
          </template>
          <template is="dom-if" if="[[canSelect]]">
            <px-context-browser-action-select class="action" asset-action="select"></px-context-browser-action-select>
          </template>
          <template is="dom-if" if="[[canOpen]]">
            <px-context-browser-action-open class="action action--open" asset-action="activate"></px-context-browser-action-favorite>
          </template>
        </div>
      </section>
    </template>

    <template is="dom-if" if="[[styleAsFavorite]]">
      <section class="context-browser-item" asset-action="select">
        <div>
          <div class="context-browser-label regular">
            [[label]]
          </div>
          <div id="breadcrumbs" class="context-browser-label context-browser-label--breadcrumbs zeta">
            <template is="dom-repeat" items="[[_truncatedBreadcrumbs]]">
              <template is="dom-if" if="[[_isNotFirstItem(index, _truncatedBreadcrumbs)]]">
                > {{item}}
              </template>
              <template is="dom-if" if="[[!_isNotFirstItem(index, _truncatedBreadcrumbs)]]">
                {{item}}
              </template>
            </template>
          </div>
        </div>
        <div class="actions">
          <template is="dom-if" if="[[canFavorite]]">
            <px-context-browser-action-favorite class="action" active$="{{favorited}}" asset-action="favorite"></px-context-browser-action-favorite>
          </template>
        </div>
      </section>
    </template>

  </template>
</dom-module>
<script>
  Polymer({
    is: 'px-context-browser-item',

    properties: {
      label: {
        type: String
      },
      breadcrumbs: {
        type: Array
      },
      _breadcrumbsFontStyles: {
        type: Object,
        computed: '_computeBreadcrumbsFontStyles(_breadcrumbsEl)'
      },
      _breadcrumbsWidth: {
        type: Number,
        computed: '_computeBreadcrumbsWidth(_breadcrumbsEl)'
      },
      _breadcrumbsEl: {
        type: HTMLElement
      },
      _truncatedBreadcrumbs: {
        type: String,
        computed: '_computeTruncatedBreadcrumbs(breadcrumbs, _breadcrumbsFontStyles, _breadcrumbsWidth, "beginning")'
      },
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      favorited: {
        type: Boolean,
        value: false
      },
      styleAsFavorite: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: '_handleStyleAsFavoriteChanged'
      },
      canSelect: {
        type: Boolean,
        value: false
      },
      canOpen: {
        type: Boolean,
        value: false
      },
      canFavorite: {
        type: Boolean,
        value: false
      }
    },

    _handleStyleAsFavoriteChanged(isStyleAsFavorite, wasStyleAsFavorite) {
      if (isStyleAsFavorite) {
        // TODO: make this work without the async
        this.async(function() {
          const breadcrumbsEl = Polymer.dom(this.root).querySelector('#breadcrumbs');
          if (breadcrumbsEl) {
            this._breadcrumbsEl = breadcrumbsEl;
          }
        }, 200);
      }
    },

    _computeBreadcrumbsFontStyles(el) {
      return this.getFontStyles(el);
    },

    _computeBreadcrumbsWidth(el) {
      return el.getBoundingClientRect().width;
    },

    _computeTruncatedBreadcrumbs(breadcrumbs, fontStyles, width, position) {
      return this.truncateBreadcrumbs(breadcrumbs, fontStyles, width);
    },

    _isNotFirstItem(index) {
      return index !== 0;
    },

    /**
     * Reads the computed font styles (font family name and font size) from the targeted
     * element and returns an object with the details.
     *
     * @param {HTMLElement} el
     * @returns {Object} styles
     * @returns {String} styles.size - The font size as a string with px suffix (e.g. '12px')
     * @returns {String} styles.family - The CSS font family declaration as a string (e.g. 'Helvetica')
     */
    getFontStyles(el) {
        var styles = window.getComputedStyle(el);
        var size = styles.fontSize;
        var family = styles.fontFamily;
        return {
            size: size,
            family: family
        }
    },

    /**
     * Iterates over a list of items and determines which will fit into the
     * available width and which will not.
     *
     * If any items do not fit, backtracks and reduces the available width to
     * ensure an overflowed icon will also fit.
     *
     * @param  {Array} items - A flat Array of items to fit
     * @param {Object} fontStyles - An object with the font size and family strings from CSSText
     * @param  {Number} width - The width to fit the items into
     * @return {Array.<Array>} - First entry is Array of items that fit, second entry is Array of items that do not fit
     */
    truncateBreadcrumbs(items, fontStyles, width) {
      let available = width;

      // If the first item is larger than the available, collapse all
      if (available < this.getTextWidth(items[0], fontStyles)) {
        return { visible: [], overflowed: items.slice(0) };
      }

      // Try to fit items in the available space
      let len = items.length;
      let i = len-1;

      while (i>=0 && available>0) {
        if (this.getTextWidth(items[i], fontStyles) > available) {
          break;
        }
        available -= this.getTextWidth(items[i], fontStyles);
        console.log(i, items[i], this.getTextWidth(items[i], fontStyles));
        i--;
      }

      // If any overflow, ensure the overflow icon can fit
      var ellipWidth = this.getTextWidth("\u2026", fontStyles);
      var caratWidth = this.getTextWidth(" > ", fontStyles);;
      let overflowSize = ellipWidth + caratWidth;
      if (i !== 0 && available < overflowSize) {
        available -= overflowSize;
        while (i<len-1 && available<0) {
          available += this.getTextWidth(items[i], fontStyles);
          i++;
        }
      }
      console.log ({ visible: items.slice(i+1), overflowed: items.slice(0,i+1) });
      return items.slice(i+1);
    },

    /**
     * Measures the given text and returns the width based on font size and family
     *
     * @param  {String} text - A text string
     * @param {Object} fontStyles - An object with the font size and family strings from CSSText
     * @return {Number} - The rounded width of the text string
     */
    getTextWidth(text, fontStyles) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      // Set the font styles
      context.font = fontStyles.size + ' ' + fontStyles.family;

      return Math.round(context.measureText(text).width);
    }

  })
</script>
