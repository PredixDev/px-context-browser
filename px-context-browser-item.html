<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-context-browser-actions.html"/>
<link rel="import" href="css/px-context-browser-item-styles.html"/>

<dom-module id="px-context-browser-item">
  <template>
    <style include="px-context-browser-item-styles"></style>

    <template is="dom-if" if="[[!styleAsFavorite]]">
      <section class="context-browser-item" asset-action="activate">
        <div class="context-browser-label regular">
          [[label]]
        </div>
        <div class="actions">
          <template is="dom-if" if="[[canFavorite]]">
            <px-context-browser-action-favorite class="action" active$="{{favorited}}" asset-action="favorite"></px-context-browser-action-favorite>
          </template>
          <template is="dom-if" if="[[canSelect]]">
            <px-context-browser-action-select class="action" asset-action="select"></px-context-browser-action-select>
          </template>
          <template is="dom-if" if="[[canOpen]]">
            <px-context-browser-action-open class="action action--open" asset-action="activate"></px-context-browser-action-favorite>
          </template>
        </div>
      </section>
    </template>

    <template is="dom-if" if="[[styleAsFavorite]]">
      <section class="context-browser-item" asset-action="select">
        <div class="context-browser-favorite--text-container">
          <div class="context-browser-label regular">
            [[label]]
          </div>
          <div id="breadcrumbs" class="context-browser-label context-browser-label--breadcrumbs zeta">
            [[_truncatedBreadcrumbs]]
          </div>
        </div>
        <div class="actions">
          <template is="dom-if" if="[[canFavorite]]">
            <px-context-browser-action-favorite class="action" active$="{{favorited}}" asset-action="favorite"></px-context-browser-action-favorite>
          </template>
        </div>
      </section>
    </template>

  </template>
</dom-module>
<script>
  Polymer({
    is: 'px-context-browser-item',

    properties: {
      label: {
        type: String
      },
      breadcrumbs: {
        type: Array
      },
      _breadcrumbsFontStyles: {
        type: Object,
        computed: '_computeBreadcrumbsFontStyles(_breadcrumbsEl)'
      },
      _breadcrumbsWidth: {
        type: Number,
        computed: '_computeBreadcrumbsWidth(_breadcrumbsEl)'
      },
      _breadcrumbsEl: {
        type: HTMLElement
      },
      _truncatedBreadcrumbs: {
        type: String,
        computed: '_computeTruncatedBreadcrumbs(breadcrumbs, _breadcrumbsFontStyles, _breadcrumbsWidth)'
      },
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      favorited: {
        type: Boolean,
        value: false
      },
      styleAsFavorite: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: '_handleStyleAsFavoriteChanged'
      },
      canSelect: {
        type: Boolean,
        value: false
      },
      canOpen: {
        type: Boolean,
        value: false
      },
      canFavorite: {
        type: Boolean,
        value: false
      }
    },

    _handleStyleAsFavoriteChanged(isStyleAsFavorite, wasStyleAsFavorite) {
      if (isStyleAsFavorite) {
        // TODO: make this work without the async
        this.async(function() {
          const breadcrumbsEl = Polymer.dom(this.root).querySelector('#breadcrumbs');
          if (breadcrumbsEl) {
            this._breadcrumbsEl = breadcrumbsEl;
          }
        }, 200);
      }
    },

    _computeBreadcrumbsFontStyles(el) {
      return this.getFontStyles(el);
    },

    _computeBreadcrumbsWidth(el) {
      var style = getComputedStyle(el);
      const paddingLeft = style.getPropertyValue('padding-left').slice(0,-2);
      const paddingRight = style.getPropertyValue('padding-right').slice(0,-2);
      const containerWidth = el.getBoundingClientRect().width;
      return (containerWidth - paddingLeft - paddingRight);
    },

    _computeTruncatedBreadcrumbs(breadcrumbs, fontStyles, width) {
      console.log(`width: ${width}`);
      return this.truncateBreadcrumbs(breadcrumbs, fontStyles, width);
    },

    _isNotFirstItem(index) {
      return index !== 0;
    },

    /**
     * Reads the computed font styles (font family name and font size) from the targeted
     * element and returns an object with the details.
     *
     * @param {HTMLElement} el
     * @returns {Object} styles
     * @returns {String} styles.size - The font size as a string with px suffix (e.g. '12px')
     * @returns {String} styles.family - The CSS font family declaration as a string (e.g. 'Helvetica')
     */
    getFontStyles(el) {
        var styles = window.getComputedStyle(el);
        var size = styles.fontSize;
        var family = styles.fontFamily;
        return {
            size: size,
            family: family
        }
    },

    /**
     * Iterates over a list of items and determines which will fit into the
     * available width and which will not.
     *
     * If any items do not fit, backtracks and reduces the available width to
     * ensure an overflowed icon will also fit.
     *
     * @param  {Array} items - A flat Array of items to fit
     * @param {Object} fontStyles - An object with the font size and family strings from CSSText
     * @param  {Number} width - The width to fit the items into
     * @return {Array.<Array>} - First entry is Array of items that fit, second entry is Array of items that do not fit
     */
    truncateBreadcrumbs(items, fontStyles, width) {
      const ellipWidth = this.getTextWidth("\u2026 > ", fontStyles);
      const caratWidth = this.getTextWidth(" > ", fontStyles);

      const available = width;
      let len = items.length;
      let visible = len;
      let lastResult;

      while (visible > 0) {
        // Get array items from end to beginning
        let itemsToFit = items.slice(visible * -1);
        // Join items together with carat
        let textToMeasure = itemsToFit.join(' > ');
        // If some items fit but not all, prepend ellipses
        if (visible < len && len > 1) {
          textToMeasure =  '... > ' + textToMeasure;
        }
        // Measure the resulting string to see if it fits
        let measure = this.getTextWidth(textToMeasure, fontStyles);
        // If it fits, we're done!
        if (available > measure) {
          return textToMeasure;
        }
        // Otherwise, try to fit with one less item
        visible--;
      }

      // We know visible === 0, truncate last item and add ... > if needed
      let prefix = (len > 1) ? '... > ' : '';
      // return prefix + items[len-1];
      return prefix + 'truncate me';
    },

    /**
     * Measures the given text and returns the width based on font size and family
     *
     * @param  {String} text - A text string
     * @param {Object} fontStyles - An object with the font size and family strings from CSSText
     * @return {Number} - The rounded width of the text string
     */
    getTextWidth(text, fontStyles) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      // Set the font styles
      context.font = fontStyles.size + ' ' + fontStyles.family;

      return Math.round(context.measureText(text).width);
    }

  })
</script>
