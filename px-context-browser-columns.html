<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="css/px-context-browser-columns-styles.html"/>
<link rel="import" href="css/px-context-browser-animations-styles.html"/>

<dom-module id="px-context-browser-columns">
  <template>
    <style include="px-context-browser-columns-styles"></style>
    <style include="px-context-browser-animations-styles"></style>

    <div id="columns" class="column-animation">
      <slot name="columns"></slot>
    </div>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'px-context-browser-columns',

    properties: {
      active: {
        type: Number,
        observer: '_activeChanged'
      },
      _activeEl: {
        type: HTMLElement,
        observer: '_activeElChanged'
      },
      _animateInEl: {
        type: HTMLElement,
        observer: '_animateInElChanged'
      },
      _animateOutEl: {
        type: HTMLElement,
        observer: '_animateOutElChanged'
      }
    },

    created: function() {
      this._onAnimateInEnd = null;
      this._onAnimateOutEnd = null;
      this._animateClassNames = {
        FADE_IN_RIGHT:  'fade-in-right',
        FADE_IN_LEFT:   'fade-in-left',
        FADE_OUT_RIGHT: 'fade-out-right',
        FADE_OUT_LEFT:  'fade-out-left'
      };
      this._distributed = false;
    },

    attached: function() {
      const tryCallActiveChanged = () => {
        if (typeof this.active === 'number' && !this._activeEl) {
          this._activeChanged(this.active);
        }
      };

      this._observer = Polymer.dom(this.$.columns).observeNodes(function(info) {
        if (!this._distributed && info.addedNodes) {
          /* Check if at least one `div.column` has been distributed */
          const nodes = Array.prototype.slice.call(info.addedNodes, 0);
          for (let i=0; i<nodes.length; i++) {
            if (nodes[i].nodeName === 'DIV' && nodes[i].classList.contains('column')) {
              this._distributed = true;
              tryCallActiveChanged();
              break;
            }
          }
        }
      }.bind(this));
    },

    detached: function() {
      Polymer.dom(this.$.columns).unobserveNodes(this._observer);
    },

    _activeChanged: function(nextActive, lastActive) {
      if (!this._distributed) return;
      let nextActiveEl = this.querySelector('[column="'+nextActive+'"]');
      if (typeof lastActive !== 'number' && nextActive === 0 && nextActiveEl === null) {
        /*
         * The next active el should probably be the first div.column even if the attribute
         * `column="0"` hasn't been defined yet because of lazy data binding. This is only
         * an issue when the component first boots
         */
        nextActiveEl = this.querySelector('div.column');
      }
      if (nextActiveEl && typeof nextActive === 'number' && nextActiveEl !== this._activeEl) {
        this._animateInClassName = (nextActive > (lastActive||0)) ? this._animateClassNames.FADE_IN_LEFT : this._animateClassNames.FADE_IN_RIGHT;
        this._animateOutClassName = (nextActive > (lastActive||0)) ? this._animateClassNames.FADE_OUT_LEFT : this._animateClassNames.FADE_OUT_RIGHT;
        this._activeEl = nextActiveEl;
      }
    },

    _activeElChanged: function(nextEl, lastEl) {
      if (lastEl && lastEl !== this._animateOutEl) {
        this._animateOutEl = lastEl;
      }
      if (nextEl && nextEl !== this._animateInEl) {
        this._animateInEl = nextEl;
      }
    },

    _animateInElChanged: function(nextEl, lastEl) {
      // Special case: skip animation if this is the first item that has moved
      // in, just show it and return.
      if (!lastEl) {
        nextEl.classList.add('active');
        return;
      }
      if (this._onAnimateInEnd && lastEl) {
        this._onAnimateInEnd();
      }
      this._onAnimateInEnd = this._setupAnimateIn(nextEl, this._animateInClassName);
    },

    _animateOutElChanged: function(nextEl, lastEl) {
      if (this._onAnimateOutEnd && lastEl) {
        this._onAnimateOutEnd();
      }
      this._onAnimateOutEnd = this._setupAnimateOut(nextEl, this._animateOutClassName);
    },

    _setupAnimateIn: function(el, animateClassName) {
      var listener = this._teardownAnimateIn.bind(this, el, animateClassName);
      el.addEventListener('animationend', listener);

      if (!el.classList.contains('animating')) {
        el.classList.add('animating');
      }
      if (!el.classList.contains(animateClassName)) {
        el.classList.add(animateClassName);
      }

      return listener;
    },

    _setupAnimateOut: function(el, animateClassName) {
      var listener = this._teardownAnimateOut.bind(this, el, animateClassName);
      el.addEventListener('animationend', listener);

      if (!el.classList.contains('animating')) {
        el.classList.add('animating');
      }
      if (el.classList.contains('active')) {
        el.classList.remove('active');
      }
      if (!el.classList.contains(animateClassName)) {
        el.classList.add(animateClassName);
      }

      return listener;
    },

    _teardownAnimateIn: function(el, animateClassName) {
      if (!el.classList.contains('active')) {
        el.classList.add('active');
      }
      if (el.classList.contains('animating')) {
        el.classList.remove('animating');
      }
      if (el.classList.contains(animateClassName)) {
        el.classList.remove(animateClassName);
      }

      el.removeEventListener('animationend', this._onAnimateInEnd);
      this._onAnimateInEnd = null;
    },

    _teardownAnimateOut: function(el, animateClassName) {
      if (el.classList.contains('active')) {
        el.classList.remove('active');
      }
      if (el.classList.contains('animating')) {
        el.classList.remove('animating');
      }
      if (el.classList.contains(animateClassName)) {
        el.classList.remove(animateClassName);
      }

      el.removeEventListener('animationend', this._onAnimateOutEnd);
      this._onAnimateOutEnd = null;
    }
  })
</script>
