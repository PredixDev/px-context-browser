<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="../web-animations-js/web-animations-next-lite.min.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-graph.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-browsable.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-selectable.html"/>
<link rel="import" href="css/px-context-browser-styles.html"/>
<link rel="import" href="px-context-browser-panel.html"/>
<link rel="import" href="px-context-browser-header.html"/>
<link rel="import" href="px-context-browser-list.html"/>
<link rel="import" href="px-context-browser-item.html"/>
<link rel="import" href="px-context-browser-behavior-animate.html"/>

<dom-module id="px-context-browser">
  <template>
    <style include="px-context-browser-styles"></style>
    <style>
      px-context-browser-panel {
        display: flex;
        flex-direction: column;
        min-height: calc(var(--px-context-browser-item-height, 30px) + 2px);
        max-height: calc(calc(var(--px-context-browser-item-height, 30px) * 10) + var(--px-context-browser-header-height, 40px));
        /*transition: max-height 300ms ease-in, min-height 300ms ease-in;*/
      }
      px-context-browser-list {
        flex: 1 1 auto;
        overflow-x: hidden;
        overflow-y: hidden;
        position: relative;
      }
      px-context-browser-header {
        display: none;
      }
      px-context-browser-header[active] {
        display: flex;
      }

      .column {
        display: none;
      }
      .column--active, .column--animating {
        display: block;
        position: absolute;
        width: 100%;
      }
      .column--animating {
        /*transition: opacity 650ms ease, transform 650ms ease;*/
      }

      @keyframes fadeInRight {
        from {
          opacity: 0;
          transform: translateX(-100%);
        }

        to {
          opacity: 1;
          transform: none;
        }
      }

      @keyframes fadeOutRight {
        from {
          opacity: 1;
          transform: none;
        }
        to {
          opacity: 0;
          transform: translateX(100%);
        }
      }

      @keyframes fadeInLeft {
        from {
          opacity: 0;
          transform: translateX(100%);
        }

        to {
          opacity: 1;
          transform: none;
        }
      }

      @keyframes fadeOutLeft {
        from {
          opacity: 1;
          transform: none;
        }
        to {
          opacity: 0;
          transform: translateX(-100%);
        }
      }

      .column--fade-in-right {
        animation-name: fadeInRight;
        animation-duration: 200ms;
      }
      .column--fade-in-left {
        animation-name: fadeInLeft;
        animation-duration: 200ms;
      }
      .column--fade-out-right {
        animation-name: fadeOutRight;
        animation-duration: 200ms;
      }
      .column--fade-out-left {
        animation-name: fadeOutLeft;
        animation-duration: 200ms;
      }
    </style>

    <px-context-browser-panel id="panel">
      <!-- Header -->
      <!-- <template is="dom-if" if="[[active]]"> -->
      <px-context-browser-header slot="header" label="[[active.label]]" on-tap="_handleHeaderTapped" id="header"></px-context-browser-header>
      <!-- </template> -->
      <!-- List -->
      <px-context-browser-list slot="body">
        <div slot="items" id="items">
          <div class="column" column="0" on-animationend="_handleColumnAnimateEnd">
            <template is="dom-repeat" items="[[_columns.0.items]]" as="item" for-column="0">
              <px-context-browser-item label="[[item.label]]" selected$="{{_isItemSelected(item, selected)}}" can-favorite can-select can-open on-tap="_handleItemTapped"></px-context-browser-item>
            </template>
          </div>
          <div class="column" column="1" on-animationend="_handleColumnAnimateEnd">
            <template is="dom-repeat" items="[[_columns.1.items]]" as="item" for-column="1">
              <px-context-browser-item label="[[item.label]]" selected$="{{_isItemSelected(item, selected)}}" can-favorite can-select can-open on-tap="_handleItemTapped"></px-context-browser-item>
            </template>
          </div>
          <div class="column" column="2" on-animationend="_handleColumnAnimateEnd">
            <template is="dom-repeat" items="[[_columns.2.items]]" as="item" for-column="2">
              <px-context-browser-item label="[[item.label]]" selected$="{{_isItemSelected(item, selected)}}" can-favorite can-select can-open on-tap="_handleItemTapped"></px-context-browser-item>
            </template>
          </div>
        </div>
      </px-context-browser-list>
    </px-context-browser-panel>
  </template>
</dom-module>
<script>
(function(){
  Polymer({
    is: 'px-context-browser',

    behaviors: [
      PxAppBehavior.AssetGraph,
      PxAppBehavior.AssetSelectable,
      PxAppBehavior.AssetBrowsable
    ],

    properties: {
      _columns: {
        type: Object,
        value: function() {
          return {
            0: {
              index: 0,
              el: null,
              items: [],
              path: []
            },
            1: {
              index: 1,
              el: null,
              items: [],
              path: []
            },
            2: {
              index: 2,
              el: null,
              items: [],
              path: []
            }
          };
        }
      },

      _activeColumn: {
        type: Number,
        value: 0,
        observer: '_activeColumnChanged'
      },

      _animationQueue: {
        type: Array,
        value: function() {
          return [];
        }
      }
    },

    created() {
      // this.__animating = [];
    },

    attached() {
      this.animator = new ColumnAnimator({
        itemHeight: parseInt(this.getComputedStyleValue('--px-context-browser-item-height') || '30px'),
        headerHeight: parseInt(this.getComputedStyleValue('--px-context-browser-header-height') || '40px'),
        borderSize: 2
      });
      this._columns[0].el = Polymer.dom(this.root).querySelector('[column="0"]');
      this._columns[1].el = Polymer.dom(this.root).querySelector('[column="1"]');
      this._columns[2].el = Polymer.dom(this.root).querySelector('[column="2"]');
      this._activeColumnChanged(this._activeColumn);
    },

    detached() {
      this._columns[0].el = this._columns[1].el = this._columns[2].el = null;
    },

    observers: [
      '_runAnimations(_animationQueue.*)'
    ],

    listeners: {
      'px-app-asset-graph-created' : '_resetColumns',
      'px-app-asset-activated' : '_handleActiveChanged',
      'px-app-asset-active-cleared' : '_handleActiveCleared'
    },

    _handleActiveChanged(evt) {
      const {item, path} = evt.detail;
      const lastColumnIndex = this._activeColumn;
      const nextColumnIndex = this._getNextColumnIndex(lastColumnIndex);
      this._setActiveColumn(item.children || [], path, nextColumnIndex);
    },

    _handleActiveCleared(evt) {
      const lastColumnIndex = this._activeColumn;
      const nextColumnIndex = this._getNextColumnIndex(lastColumnIndex);
      this._setActiveColumn(this.items, [], nextColumnIndex);
    },

    _resetColumns() {
      this._setActiveColumn(this.items, [], 0);
    },

    _getNextColumnIndex(lastIndex) {
      return lastIndex === 2 ? 0 : lastIndex+1;
    },

    _setActiveColumn(children, path, nextColumnIndex) {
      if (this._columns[nextColumnIndex].items !== children) {
        this.set(`_columns.${nextColumnIndex}.items`, children);
      }
      if (this._columns[nextColumnIndex].path !== path) {
        this.set(`_columns.${nextColumnIndex}.path`, path);
      }
      this._activeColumn = nextColumnIndex;
    },

    _activeColumnChanged(nextColumnIndex, lastColumnIndex) {
      if (typeof this._columns !== 'object' || !this.isAttached) return;

      const nextColumn = this._columns[nextColumnIndex];
      const lastColumn = this._columns[lastColumnIndex];

      // There is no last column, just set the next to active
      if (typeof lastColumnIndex === 'undefined') {
        // const firstPanelHeight = this._calculatePanelHeight(nextColumn.items.length, (nextColumn.path.length===0), 0);
        const firstPanelHeight = this.animator._calculatePanelHeight(nextColumn.items.length, true);
        this.$.panel.style.minHeight = `${firstPanelHeight}px`;
        if (!this._columns[nextColumnIndex].el.classList.contains('column--active')) {
          this._columns[nextColumnIndex].el.classList.add('column--active');
        }
        return;
      }

      // this.push('_animationQueue', {lastColumn, nextColumn});

      const nextColumnIsRoot = (nextColumn.path.length === 0);
      const currentPanelHeight = this.$.panel.style.minHeight;
      const nextPanelHeight = this._calculatePanelHeight(nextColumn.items.length, nextColumnIsRoot, currentPanelHeight);
      const movingIntoGraph = (nextColumn.path.length > lastColumn.path.length);

      this.animator.add({
        outEl: lastColumn.el,
        outItemCount: lastColumn.items.length,
        outIsRoot: lastColumn.path.length === 0,
        inEl: nextColumn.el,
        inItemCount: nextColumn.items.length,
        inIsRoot: nextColumn.path.length === 0,
        panelEl: this.$.panel,
        headerEl: this.$.header,
        isMovingDown: movingIntoGraph
      });

      // 0. Determine if we're moving down or up
      // 1. Measure the necessary height for the next items column. If no items yet, height should be the same.
      // 2. Apply exit classes
      // 3. Change panel height
      // 4. Apply entry classes
      // const nextColumnIsRoot = (nextColumn.path.length === 0);
      // const currentPanelHeight = this.$.panel.style.minHeight;
      // const nextPanelHeight = this._calculatePanelHeight(nextColumn.items.length, nextColumnIsRoot, currentPanelHeight);
      // const movingIntoGraph = (nextColumn.path.length > lastColumn.path.length);

      // lastColumn.el.classList.remove('column--active');
      // lastColumn.el.classList.add('column--animating');
      // lastColumn.el.classList.add(movingIntoGraph ? 'column--fade-out-right' : 'column--fade-out-left');
      //
      // this.$.panel.style.minHeight = nextPanelHeight;
      //
      // nextColumn.el.classList.add('column--active');
      // nextColumn.el.classList.add(movingIntoGraph ? 'column--fade-in-right' : 'column--fade-in-left');
      // nextColumn.el.classList.add('column--animating');
    },

    _runAnimations(retries=1) {
      if (this._animationQueue.length === 0) return;

      this.debounce('run-animations', function() {
        if (this._animationQueue.length > 5) {
          this._animationQueue = this._animationQueue.slice(-1);
          return;
        }

        if (this.__animating) {
          console.log('____ Wait');
          window.requestAnimationFrame(this._runAnimations.bind(this));
          return;
        }

        console.log('---- Running');

        const {nextColumn, lastColumn} = this.shift('_animationQueue');
        this.__animating = true;
        this._wrapAnimation(nextColumn, lastColumn, (this._animationQueue.length > 1)).then(() => {
          console.log('---- Done');
          this.__animating = false;
        })
      }, 10);
    },

    _wrapAnimation(nextColumn, lastColumn, doFast) {
      return new Promise((resolve, reject) => {
        let animating = 2;

        const nextColumnIsRoot = (nextColumn.path.length === 0);
        const currentPanelHeight = this.$.panel.style.minHeight;
        const nextPanelHeight = this._calculatePanelHeight(nextColumn.items.length, nextColumnIsRoot, currentPanelHeight);
        const movingIntoGraph = (nextColumn.path.length > lastColumn.path.length);

        console.log(`out: ${lastColumn.el.getAttribute('column')}`);
        lastColumn.el.classList.remove('column--active');
        lastColumn.el.classList.add('column--animating');
        let fadeOutClass = movingIntoGraph ? 'column--fade-out-right' : 'column--fade-out-left';
        if (doFast) fadeOutClass = fadeOutClass + '--fast';
        lastColumn.el.classList.add(fadeOutClass);
        this._boundHandleAnimateOutEnd = () => {
          animating--;
          console.log('Out Done...' + animating);
          lastColumn.el.classList.remove('column--animating');
          lastColumn.el.classList.remove(fadeOutClass);
          lastColumn.el.removeEventListener('animationend', this._boundHandleAnimateOutEnd);
          if (animating === 0) resolve();
        };
        lastColumn.el.addEventListener('animationend', this._boundHandleAnimateOutEnd);

        this.$.panel.style.minHeight = nextPanelHeight;

        console.log(`in: ${nextColumn.el.getAttribute('column')}`);
        nextColumn.el.classList.add('column--active');
        let fadeInClass = movingIntoGraph ? 'column--fade-in-right' : 'column--fade-in-left';
        if (doFast) fadeInClass + '--fast';
        nextColumn.el.classList.add(fadeInClass);
        nextColumn.el.classList.add('column--animating');
        this._boundHandleAnimateInEnd = () => {
          animating--;
          console.log('In Done...' + animating);
          console.log(animating.length === 0);
          nextColumn.el.classList.remove('column--animating');
          nextColumn.el.classList.remove(fadeInClass);
          nextColumn.el.removeEventListener('animationend', this._boundHandleAnimateInEnd);
          if (animating === 0) resolve();
        };
        nextColumn.el.addEventListener('animationend', this._boundHandleAnimateInEnd);
      });
    },

    _calculatePanelHeight(columnItemCount, columnIsRoot, currentPanelHeight) {
      const borderStrokeSize = 2;
      const itemHeight = parseInt(this.getComputedStyleValue('--px-context-browser-item-height') || '30px');
      const headerHeight = columnIsRoot ? 0 : parseInt(this.getComputedStyleValue('--px-context-browser-header-height') || '40px');
      const minimumHeight = itemHeight + headerHeight + borderStrokeSize;

      // If there are no columns, we should just return the current height or the
      // minimum height (header+1 item), whichever is larger.
      if (columnItemCount === 0) {
        return parseInt(currentPanelHeight) > minimumHeight ? `${currentPanelHeight}px` : `${minimumHeight}px`;
      }
      else {
        const itemMultiplier = (columnItemCount > 10) ? 10 : columnItemCount;
        const itemTotalHeight = parseInt(itemHeight) * itemMultiplier;
        return `${itemTotalHeight + headerHeight + borderStrokeSize}px`;
      }
    },

    _handleColumnAnimateEnd(evt) {
      // const column = Polymer.dom(evt).rootTarget;
      // console.log(`done: ${column.getAttribute('column')}`);
      // column.classList.remove('column--animating');
      // if (column.classList.contains('column--fade-in-right')) column.classList.remove('column--fade-in-right');
      // if (column.classList.contains('column--fade-out-right')) column.classList.remove('column--fade-out-right');
      // if (column.classList.contains('column--fade-in-left')) column.classList.remove('column--fade-in-left');
      // if (column.classList.contains('column--fade-out-left')) column.classList.remove('column--fade-out-left');
      // // const animateClassName = this._findAnimateClassName(column.classList.toString());
      // // column.classList.remove(animateClassName);
      // this.__animating.splice(this.__animating.indexOf(column), 1);
    },

    _findAnimateClassName(classList) {
      const match = classList.match(/(\s|^)(column--fade-[a-zA-Z-]+)(\s|$)/);
      return match ? match[2] : null;
    },

    _handleItemTapped(evt) {
      const $root = Polymer.dom(evt).path[0];
      const action = $root.getAttribute('asset-action');
      const item = evt.model.item;

      if (typeof action === 'string' && action.length > 0 && typeof item === 'object') {
        switch(action) {
          case 'activate':
            this.activate(item, 'DOM_EVENT');
            break;
          case 'select':
            this.select(item, 'DOM_EVENT');
            break;
          case 'favorite':
            // @TODO: Implement favorite storage/notification behavior
            break;
        }
      }
    },

    _handleHeaderTapped(evt) {
      const path = Polymer.dom(evt).path;
      const action = this._findActionInPath(path);

      if (typeof action !== 'string' || action.length > 0) {
        // if activeParent is `null`, the root will be activated
        this.activate(this.activeParent, 'DOM_EVENT');
      }
    },

    _findActionInPath(path) {
      let action;
      for (let i=0; i<path.length; i++) {
        if (path[i] instanceof Node && path[i].hasAttribute && path[i].hasAttribute('asset-action')) {
          action = path[i].getAttribute('asset-action');
          break;
        }
      }
      return action;
    },

    _isItemSelected(item, selected) {
      return typeof selected === 'object' && selected === item;
    }
  });

  function toRegex(str) {
    return new RegExp(str);
  };

  function updateClassNames(list, updates) {
    let items = list.split(' ');
    let {add=[], remove=[]} = updates;

    let classNames = items.reduce((acc, item) => {
      let addIndex = add.indexOf(item);
      if (addIndex > -1) {
        add.splice(addIndex-1, addIndex);
        return acc;
      }
      if (remove.indexOf(item) > -1) {
        return acc;
      }
      return acc.concat([item]);
    }, []);

    return [...classNames, ...add].join(' ');
  };

  function addClassName(className, list) {
    if (hasClassName(className, list)) return list;
    return `${list} ${className}`.trim().replace('  ', ' ');
  };

  function removeClassName(className, list) {
    return list.replace(className, '').replace('  ', ' ');
  };

  function hasClassName(className, list) {
    return toRegex(`(\\s|^)${className}(\\s|$)`).test(list) === true;
  };
})();

class ColumnAnimator {
  constructor({itemHeight, headerHeight, borderSize}) {
    this.itemHeight = itemHeight;
    this.headerHeight = headerHeight;
    this.borderSize = borderSize;

    this._animationQueue = [];
  }

  add(options) {
    return this._createAnimation(options);
  }

  _createAnimation({outEl, inEl, headerEl, panelEl, outItemCount, inItemCount, outIsRoot, inIsRoot, isMovingDown}) {
    const animations = {};

    // Animate header in/out
    const willHaveHeader = !inIsRoot;
    const headerSlidingIn = (outIsRoot && !inIsRoot);
    const headerSlidingOut = (!outIsRoot && inIsRoot);
    // if (headerSlidingIn) {
    //   animations.header = this._generateAnimation(headerEl, {
    //     animate: ColumnAnimator.slideInDown,
    //     before: (el) => {
    //       el.style.height = 'auto';
    //       el.setAttribute('active', '')
    //     }
    //   });
    // }
    // if (headerSlidingOut) {
    //   animations.header = this._generateAnimation(headerEl, {
    //     animate: ColumnAnimator.slideOutUp,
    //     after: (el) => {
    //       el.style.height = '0px';
    //       el.removeAttribute('active')
    //     }
    //   });
    // }

    if (headerSlidingIn) {
      animations.header = this._generateAnimation(headerEl, {
        animate: ColumnAnimator.popIn,
        before: (el) => {
          el.setAttribute('active', '')
        }
      });
    }
    if (headerSlidingOut) {
      animations.header = this._generateAnimation(headerEl, {
        animate: (el, duration) => ColumnAnimator.popOut(el, '0px', '-40px', duration),
        after: (el) => {
          el.removeAttribute('active')
        }
      });
    }

    // Animate columns in/out
    animations.out = this._generateAnimation(outEl, {
      animate: isMovingDown ? ColumnAnimator.fadeOutLeft : ColumnAnimator.fadeOutRight,
      after: (el) => el.classList.remove('column--active')
    });
    animations.in = this._generateAnimation(inEl, {
      animate: (el, duration) => {
        if (headerSlidingOut) {
          return ColumnAnimator.fadeInLeftFromTop(el, duration, '-40px');
        }
        if (isMovingDown) {
          return ColumnAnimator.fadeInRight(el, duration);
        }
        return ColumnAnimator.fadeInLeft(el, duration);
      },
      before: (el) => {
        el.classList.add('column--active')
      }
    });

    // Animate panel height
    let lastPanelHeight = this._calculatePanelHeight(outItemCount, !outIsRoot);
    if (headerSlidingIn && lastPanelHeight < this.headerHeight) lastPanelHeight = this.headerHeight;
    let nextPanelHeight = (inItemCount > 0) ? this._calculatePanelHeight(inItemCount, !inIsRoot) : lastPanelHeight;
    // animations.panel = panelEl.animate({
    //   minHeight: [`${lastPanelHeight}px`, `${nextPanelHeight}px`]
    // }, {
    //   duration: 250
    // });
    // animations.panelPromise = new Promise(resolve =>
    //   animations.panel.onfinish = () => {
    //     panelEl.style.minHeight = `${nextPanelHeight}px`;
    //     resolve();
    //   }
    // );
    animations.panel = this._generateAnimation(panelEl, {
      animate: (el, defaultDuration) => ColumnAnimator.scaleHeight(el, `${lastPanelHeight}px`, `${nextPanelHeight}px`, defaultDuration),
      before: (el) => {
        el.style.minHeight = `${lastPanelHeight}px`;
        if (willHaveHeader) el.setAttribute('has-header', '');
        if (!willHaveHeader) el.removeAttribute('has-header');
      },
      after: (el) => el.style.minHeight = `${nextPanelHeight}px`
    });

    return Promise.all([animations.in(), animations.out(), animations.panel(), animations.header ? animations.header() : Promise.resolve()]);
  }

  _generateAnimation(el, {animate, before, after}) {
    return () => {
      if (typeof before === 'function') {
        before.call(this, el);
      }
      return animate.call(this, el, 250).finished.then((a) => {
        if (typeof after === 'function') {
          after.call(this, el);
        }
        return Promise.resolve(a);
      });
    };
  }

  _calculatePanelHeight(itemCount, hasHeader) {
    let addForHeader = hasHeader ? this.headerHeight : 0;
    let addForItem;
    if (itemCount === 0) {
      addForItem = this.itemHeight;
    }
    if (itemCount > 0 && itemCount < 10) {
      addForItem = this.itemHeight * itemCount;
    }
    if (itemCount >= 10) {
      addForItem = this.itemHeight * 10;
    }
    let addForBorder = this.borderSize;
    return addForHeader + addForItem + addForBorder;
  }

  static fadeInRight(el, duration) {
    const keyframes = [
      { transform: 'translateX(-100%)', opacity: '0' },
      { transform: 'none', opacity: '1' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static fadeOutRight(el, duration) {
    const keyframes = [
      { transform: 'none', opacity: '1' },
      { transform: 'translateX(-100%)', opacity: '0' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static fadeInLeft(el, duration) {
    const keyframes = [
      { transform: 'translateX(100%)', opacity: '0' },
      { transform: 'none', opacity: '1' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static fadeInLeftFromTop(el, duration, topPosition) {
    const keyframes = [
      { transform: `translate(100%, ${topPosition})`, opacity: '0' },
      { transform: 'none', opacity: '1' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static fadeOutLeft(el, duration) {
    const keyframes = [
      { transform: 'none', opacity: '1' },
      { transform: 'translateX(100%)', opacity: '0' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static scaleHeight(el, startHeight, endHeight, duration) {
    const keyframes = [
      { minHeight: startHeight },
      { minHeight: endHeight }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static slideInDown(el, duration) {
    const keyframes = [
      { transform: 'translateY(-100%)' },
      { transform: 'none' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static slideOutUp(el, duration) {
    const keyframes = [
      { transform: 'none' },
      { transform: 'translateY(-100%)' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static popIn(el, duration) {
    const keyframes = [
      { opacity: '0' },
      { opacity: '1' }
    ];
    return el.animate(keyframes, { duration: duration });
  }

  static popOut(el, startMarginBottom, endMarginBottom, duration) {
    const keyframes = [
      { opacity: '1', marginBottom: startMarginBottom },
      { opacity: '0', marginBottom: endMarginBottom }
    ];
    return el.animate(keyframes, { duration: duration });
  }
};
</script>
