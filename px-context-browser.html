<link rel="import" href="../polymer/polymer.html"/>

<link rel="import" href="../web-animations-js/web-animations-next-lite.min.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>
<link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html"/>
<link rel="import" href="../iron-dropdown/iron-dropdown.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-graph.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-selectable.html"/>
<link rel="import" href="../px-app-helpers/px-app-asset/px-app-asset-behavior-activatable.html"/>
<link rel="import" href="css/px-context-browser-styles.html"/>
<link rel="import" href="px-context-browser-panel.html"/>
<link rel="import" href="px-context-browser-header.html"/>
<link rel="import" href="px-context-browser-list.html"/>
<link rel="import" href="px-context-browser-item.html"/>

<dom-module id="px-context-browser">
  <template>
    <style include="px-context-browser-styles"></style>
    <iron-a11y-keys target="[[_panelEl]]" keys="up" on-keys-pressed="_focusLast" stop-keyboard-event-propagation></iron-a11y-keys>
    <iron-a11y-keys target="[[_panelEl]]" keys="down" on-keys-pressed="_focusNext" stop-keyboard-event-propagation></iron-a11y-keys>
    <iron-a11y-keys target="[[_panelEl]]" keys="enter" on-keys-pressed="_handleEnterKey" stop-keyboard-event-propagation></iron-a11y-keys>
    <iron-a11y-keys target="[[_panelEl]]" keys="left" on-keys-pressed="_handleArrowLeftKey" stop-keyboard-event-propagation></iron-a11y-keys>

    <iron-dropdown
      id="dropdown"
      no-overlap
      vertical-align="top"
      horizontal-align="left"
      horizontal-offset="-15"
      opened="{{opened}}"
      position-target="[[_positionTarget]]"
      on-iron-overlay-canceled="_handleDropdownCanceled">
      <px-context-browser-panel id="panel" has-header$="[[_isHeaderActive(_columns, _activeColumn)]]" slot="dropdown-content">
        <px-context-browser-header slot="header" label="[[active.label]]" on-tap="_handleHeaderTapped" can-select can-favorite="[[hasFavorites]]" id="header"></px-context-browser-header>
        <px-context-browser-list id="list" slot="body" can-filter="[[hasFilter]]" filter="{{filter}}" loading="[[_activeColumnLoading]]">
          <div slot="items" id="items" class="items">
            <div class="column" column="0">
              <template is="dom-repeat" items="[[_columns.0.items]]" as="item" for-column="0" filter="_isItemVisible" observe="visible" delay="10" on-dom-change="_handleVisibleCountChanged">
                <px-context-browser-item label="[[item.source.label]]" selected$="{{_isItemSelected(item.source, selected)}}" can-favorite="[[hasFavorites]]" can-select can-open="[[_isItemOpenable(openArrow, item.source)]]" on-tap="_handleItemTapped" tabindex="0"></px-context-browser-item>
              </template>
            </div>
            <div class="column" column="1">
              <template is="dom-repeat" items="[[_columns.1.items]]" as="item" for-column="1" filter="_isItemVisible" observe="visible" delay="10" on-dom-change="_handleVisibleCountChanged">
                <px-context-browser-item label="[[item.source.label]]" selected$="{{_isItemSelected(item.source, selected)}}" can-favorite="[[hasFavorites]]" can-select can-open="[[_isItemOpenable(openArrow, item.source)]]" on-tap="_handleItemTapped" tabindex="0"></px-context-browser-item>
              </template>
            </div>
            <div class="column" column="2">
              <template is="dom-repeat" items="[[_columns.2.items]]" as="item" for-column="2" filter="_isItemVisible" observe="visible" delay="10" on-dom-change="_handleVisibleCountChanged">
                <px-context-browser-item label="[[item.source.label]]" selected$="{{_isItemSelected(item.source, selected)}}" can-favorite="[[hasFavorites]]" can-select can-open="[[_isItemOpenable(openArrow, item.source)]]" on-tap="_handleItemTapped" tabindex="0"></px-context-browser-item>
              </template>
            </div>
          </div>
        </px-context-browser-list>
      </px-context-browser-panel>
    </iron-dropdown>
  </template>
</dom-module>
<script>
(function(){
  Polymer({
    is: 'px-context-browser',

    behaviors: [
      PxAppBehavior.AssetGraph,
      PxAppBehavior.AssetSelectable,
      PxAppBehavior.AssetActivatable,
      Polymer.IronResizableBehavior
    ],

    properties: {
      openArrow: {
        type: Boolean,
        value: false
      },
      hasFavorites: {
        type: Boolean,
        value: false
      },
      /**
       * Enables filtering the visible assets. Set to `true` to show a filter
       * input above each asset list.
       */
      hasFilter: {
        type: Boolean,
        value: false
      },
      /**
       * The active filter. Updates when the user types into the filter input.
       * Set a new value to filter programatically.
       */
      filter: {
        type: String,
        notify: true,
        observer: '_filterChanged'
      },
      /**
       * The number of milliseconds to wait for an active item with no children
       * to have children provided. Defaults to 5 seconds. Set to `0` to wait
       * forever.
       */
      loadingTimeout: {
        type: Number,
        value: 5000,
        observer: 'cancelLoading'
      },
      /**
       * Updated when the context browser attempts to load additional children.
       */
      loading: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      /**
       * Enable to mark items whose children cannot be loaded before the
       * `loadingTimeout` as terminal â€” prevents the item from being activated.
       */
      loadingFailureTerminal: {
        type: Boolean,
        value: false
      },
      openTrigger: {
        type: HTMLElement,
        observer: '_openTriggerChanged'
      },
      favoritesTrigger: {
        type: HTMLElement,
        observer: '_favoritesTriggerChanged'
      },
      _positionTarget: {
        type: HTMLElement
      },
      /**
       * If `true` the context browser is opened.
       */
      opened: {
        type: Boolean,
        value: false
      },
      _columns: {
        type: Object,
        value: function() {
          return {
            0: {
              index: 0,
              el: null,
              parent: null,
              items: [],
              path: [],
              loading: false
            },
            1: {
              index: 1,
              el: null,
              parent: null,
              items: [],
              path: [],
              loading: false
            },
            2: {
              index: 2,
              el: null,
              parent: null,
              items: [],
              path: [],
              loading: false
            }
          };
        }
      },

      _activeColumn: {
        type: Number,
        observer: '_activeColumnChanged'
      },

      _activeColumnRef: {
        type: Object,
        computed: '_getActiveColumnRef(_activeColumn)'
      },

      _activeColumnLoading: {
        type: Boolean,
        value: false,
        computed: '_isActiveColumnLoading(_activeColumnRef.loading)',
        observer: '_activeColumnLoadingChanged'
      },

      _visibleItemCount: {
        type: Number,
        observer: '_animateColumnHeight'
      },

      _panelEl: {
        type: HTMLElement
      }
    },

    created() {
      this._openTriggerHandler = null;
      this._favoritesTriggerChanged = null;
    },

    _openTriggerChanged(newTrigger, oldTrigger) {
      if (oldTrigger && oldTrigger instanceof HTMLElement && this._openTriggerHandler !== null) {
        oldTrigger.removeEventListener('trigger-tapped', this._openTriggerHandler);
        this._openTriggerHandler = null;
      }
      if (newTrigger && newTrigger instanceof HTMLElement) {
        this._openTriggerHandler = newTrigger.addEventListener('trigger-tapped', this._handleOpenTriggerTapped.bind(this));
      }
    },

    _favoritesTriggerChanged(newTrigger, oldTrigger) {
      if (oldTrigger && oldTrigger instanceof HTMLElement && this._favoritesTriggerHandler !== null) {
        oldTrigger.removeEventListener('trigger-tapped', this._favoritesTriggerHandler);
        this._favoritesTriggerHandler = null;
      }
      if (newTrigger && newTrigger instanceof HTMLElement) {
        this._favoritesTriggerHandler = newTrigger.addEventListener('trigger-tapped', this._handleFavoritesTriggerTapped.bind(this));
      }
    },

    _handleOpenTriggerTapped(evt) {
      if (!this.opened) {
        this._positionTarget = Polymer.dom(evt).rootTarget;
        this.opened = true;
      }
      else {
        this.$.dropdown.close();
      }
    },

    _handleFavoritesTriggerTapped(evt) {
      // @TODO: Implement favorites trigger behavior
    },

    _handleDropdownCanceled(evt) {
      if (!this.openTrigger) return;

      const path = Polymer.dom(evt.detail).path;
      if (path.indexOf(this.openTrigger) > -1) {
        evt.preventDefault();
      }
    },

    _getActiveColumnRef(index) {
      return this._columns[index];
    },

    _isActiveColumnLoading(isLoading) {
      return isLoading || false;
    },

    _activeColumnLoadingChanged(isLoading, wasLoading) {
      this.__loadingHandler = this.__loadingHandler || null;
      if (isLoading && !wasLoading) {
        if (this.__loadingHandler) {
          this.cancelLoading();
        }
        this._setLoading(true);
        this.__loadingHandler = this.async(function(){
          if (this.loadingFailureTerminal) {
            this._assetGraph.setTerminal(this.active, true);
          }
          this.activate(this.activeMeta.parent, 'LOADING_FAILED');
          this.__loadingHandler = null;
        }, this.loadingTimeout);
      }
      else if (!isLoading && wasLoading && this.__loadingHandler) {
        this._setLoading(false);
        this.cancelLoading();
      }
    },

    cancelLoading() {
      if (this.__loadingHandler) {
        this._setLoading(false);
        this.cancelAsync(this.__loadingHandler);
        this.__loadingHandler = null;
      }
    },

    _focusLast(evt) {
      evt.detail.keyboardEvent.preventDefault();
      const srcItem = Polymer.dom(evt.detail.keyboardEvent).rootTarget;
      const lastItem = srcItem.previousElementSibling;
      if (lastItem && lastItem.nodeName === 'PX-CONTEXT-BROWSER-ITEM') {
        lastItem.focus();
      }
      else if (this.hasFilter) {
        const listEl = Polymer.dom(this.root).querySelector('#list');
        if (listEl) {
          listEl.focusInput();
        }
      }
    },

    _focusNext(evt) {
      evt.detail.keyboardEvent.preventDefault();
      const srcItem = Polymer.dom(evt.detail.keyboardEvent).rootTarget;
      const nextItem = srcItem.nextElementSibling;
      if (nextItem && nextItem.nodeName === 'PX-CONTEXT-BROWSER-ITEM') {
        // If the next element is another context browser item, focus it
        nextItem.focus();
      }
      else if (srcItem.parentElement.childElementCount > 1) {
        // If the next element isn't an item, focus the first item in the list
        const firstSibling = this._getFirstSibling(srcItem, srcItem.parentElement.children, 'PX-CONTEXT-BROWSER-ITEM');
        if (firstSibling) {
          firstSibling.focus();
        }
      }
    },

    _focusFirstVisibleItem(evt) {
      if (typeof this._columns === 'object' && typeof this._activeColumn === 'number' && this._columns[this._activeColumn]) {
        const firstItem = this._getFirstSibling(null, this._columns[this._activeColumn].el.children, 'PX-CONTEXT-BROWSER-ITEM');
        if (firstItem) {
          firstItem.focus();
        }
      }
    },

    _handleEnterKey(evt) {
      const target = Polymer.dom(evt.detail.keyboardEvent).rootTarget;
      if (target.nodeName === 'PX-CONTEXT-BROWSER-ITEM') {
        const repeatEl = Polymer.dom(this._columns[this._activeColumn].el).querySelector('template[is="dom-repeat"]');
        const model = repeatEl.modelForElement(target);
        this.select(model.item.source, 'DOM_EVENT');
      }
    },

    _handleArrowLeftKey(evt) {
      // @TODO: Starting to be a lot of repeat code here. What's a better
      // way to do this that's succinct?

      // DESIRED BEHAVIOR: If there's a parent, go up to it. If not, go up to root.

      const target = Polymer.dom(evt.detail.keyboardEvent).rootTarget;
      if (target.nodeName === 'PX-CONTEXT-BROWSER-ITEM') {
        const repeatEl = Polymer.dom(this._columns[this._activeColumn].el).querySelector('template[is="dom-repeat"]');
        const item = repeatEl.modelForElement(target).item.source;
        const parent = this._assetGraph.getNodeInfo(item).parent;
        if (parent) {
          this.activate(parent, 'DOM_EVENT');
        } else {
          this.activate(null, 'DOM_EVENT');
        }
      }
    },

    _getFirstSibling(source, siblings, targetNodeName) {
      for (let i=0; i<siblings.length; i++) {
        if (siblings[i].nodeName === targetNodeName && siblings[i] !== source) {
          return siblings[i];
        }
      }
    },

    attached() {
      this._panelElement = Polymer.dom(this.root).querySelector('#panel');
      this.animator = new ColumnAnimator({
        itemHeight: parseInt(this.getComputedStyleValue('--px-context-browser-item-height') || '30px'),
        headerHeight: parseInt(this.getComputedStyleValue('--px-context-browser-header-height') || '40px'),
        borderSize: 2
      });
      this._columns[0].el = Polymer.dom(this.root).querySelector('[column="0"]');
      this._columns[1].el = Polymer.dom(this.root).querySelector('[column="1"]');
      this._columns[2].el = Polymer.dom(this.root).querySelector('[column="2"]');
      if (this.items) {
        this._activeColumnChanged(this._activeColumn);
      }
    },

    detached() {
      this._columns[0].el = this._columns[1].el = this._columns[2].el = null;
    },

    listeners: {
      'px-app-asset-graph-created' : '_resetColumns',
      'px-app-asset-activated' : '_handleActiveChanged',
      'px-app-asset-deactivated' : '_resetColumns',
      'focus-first-visible-item' : '_focusFirstVisibleItem',
      'px-app-asset-children-updated' : '_handleChildrenChanged'
    },

    _handleChildrenChanged(evt) {
      const {item, path, children, isTerminal, hasChildren} = evt.detail;
      if (this._columns[this._activeColumn].parent !== item) return;
      this.cancelLoading();

      if (isTerminal || !hasChildren) {
        this.activate(this.activeMeta.parent, 'LOADING_FAILED');
        return;
      }

      let slicedChildren = children.map(c => ({ source: c, visible: true }));
      if (this.hasFilter && typeof this.filter === 'string' && this.filter.length) {
        this._filterAndMutateItems(slicedChildren, true, this.filter);
      }
      this.set(`_columns.${this._activeColumn}.loading`, false);
      this.set(`_columns.${this._activeColumn}.items`, slicedChildren);
      this.notifyPath(`_activeColumnRef.loading`);
    },


    _handleActiveChanged(evt) {
      const {item, path} = evt.detail;
      const lastColumnIndex = this._activeColumn;
      const nextColumnIndex = this._getNextColumnIndex(lastColumnIndex);
      this._setActiveColumn(item, this._assetGraph.getChildren(item), path, nextColumnIndex);

      if (this._assetGraph.hasNode(item) && !this._assetGraph.isTerminal(item) && !this._assetGraph.isExhausted(item) && !this._assetGraph.hasChildren(item)) {
        this.fire('px-app-asset-children-requested', {
          item: item,
          path: path
        });
      }
    },

    _resetColumns() {
      const lastColumnIndex = this._activeColumn;
      const nextColumnIndex = typeof lastColumnIndex === 'number' ? this._getNextColumnIndex(lastColumnIndex) : 0;
      this._setActiveColumn(null, this.items, [], nextColumnIndex);
    },

    _getNextColumnIndex(lastIndex) {
      return lastIndex === 2 ? 0 : lastIndex+1;
    },

    _setActiveColumn(parent, children, path, nextColumnIndex) {
      if (this.hasFilter) {
        this.filter = '';
      }
      const loading = (!this._assetGraph.isTerminal(parent) && !this._assetGraph.hasChildren(parent));
      this.set(`_columns.${nextColumnIndex}.loading`, loading);
      this.set(`_columns.${nextColumnIndex}.items`, children.map(c => ({source:c, visible:true})));
      this.set(`_columns.${nextColumnIndex}.path`, path);
      this.set(`_columns.${nextColumnIndex}.parent`, parent);
      this._activeColumn = nextColumnIndex;
    },

    _activeColumnChanged(nextColumnIndex, lastColumnIndex) {
      if (typeof this._columns !== 'object' || !this.isAttached) return;

      const nextColumn = this._columns[nextColumnIndex];
      const nextColumnIsRoot = (nextColumn.path.length === 0);
      const nextColumnHasHeader = !nextColumnIsRoot;

      if (typeof lastColumnIndex === 'undefined') {
        if (!this._columns[nextColumnIndex].el.classList.contains('column--active')) {
          this._columns[nextColumnIndex].el.classList.add('column--active');
        }
        return;
      }

      const lastColumn = this._columns[lastColumnIndex];
      const lastColumnIsRoot = (lastColumn.path.length === 0);
      const lastColumnHasHeader = !lastColumnIsRoot;
      const isMovingDown = (nextColumn.path.length > lastColumn.path.length);
      this.animator.add({
        outEl: lastColumn.el,
        outItemCount: lastColumn.items.length,
        outHasHeader: lastColumnHasHeader,
        inEl: nextColumn.el,
        inItemCount: nextColumn.items.length,
        inHasHeader: nextColumnHasHeader,
        headerEl: this.$.header,
        isMovingDown: isMovingDown
      });
    },

    _handleItemTapped(evt) {
      evt.stopPropagation();
      const $root = Polymer.dom(evt).path[0];
      const action = $root.getAttribute('asset-action');
      const item = evt.model.item.source;

      if (typeof action === 'string' && action.length > 0 && typeof item === 'object') {
        const isTerminal = this._assetGraph.isTerminal(item);
        if (!isTerminal && action === 'activate') {
          this.activate(item, 'DOM_EVENT');
        }
        else if (action === 'select' || (isTerminal && action === 'activate')) {
          this.select(item, 'DOM_EVENT');
        }
        else if (action === 'favorite') {
          // @TODO: Implement favorite storage/notification behavior
        }
      }
    },

    _handleHeaderTapped(evt) {
      const path = Polymer.dom(evt).path;
      const action = this._findActionInPath(path);

      if (typeof action !== 'string' || action.length > 0) {
        switch(action) {
          case 'back':
            // if activeParent is `null`, the root will be activated
            this.activate(this.activeMeta.parent, 'DOM_EVENT');
            break;
          case 'select':
            this.select(this.active, 'DOM_EVENT');
            break;
          case 'favorite':
            // @TODO: Implement favorite storage/notification behavior
            break;
        }
      }
    },

    _findActionInPath(path) {
      let action;
      for (let i=0; i<path.length; i++) {
        if (path[i] instanceof Node && path[i].hasAttribute && path[i].hasAttribute('asset-action')) {
          action = path[i].getAttribute('asset-action');
          break;
        }
      }
      return action;
    },

    _isItemSelected(item, selected) {
      return typeof selected === 'object' && selected === item;
    },

    _isItemVisible(item) {
      return item.visible === true;
    },

    _isItemOpenable(canOpen, item) {
      return canOpen && !this._assetGraph.isTerminal(item);
    },

    _filterChanged(nextFilter, lastFilter) {
      if (typeof this._activeColumn !== 'number' || typeof nextFilter !== 'string' || (nextFilter.length === 0 && typeof lastFilter !== 'string')) {
        return;
      }
      this._filterAndMutateItems(this._columns[this._activeColumn].items, nextFilter.length > 0, nextFilter);
    },

    _filterAndMutateItems(items, filterIsActive, filterString) {
      if (items && !filterIsActive) {
        for (let i=0; i<items.length; i++) {
          items[i].visible = true;
          this.notifyPath(`_columns.${this._activeColumn}.items.${i}.visible`);
        }
      }
      else if (items && filterIsActive) {
        const filter = filterString.toLowerCase();
        for (let i=0; i<items.length; i++) {
          items[i].visible = (items[i].source.label.toLowerCase().indexOf(filter) > -1);
          this.notifyPath(`_columns.${this._activeColumn}.items.${i}.visible`);
        }
      }
    },

    _handleVisibleCountChanged(evt) {
      if (typeof this._activeColumn !== 'number') return;

      const target = Polymer.dom(evt).rootTarget;
      const columnIndex = target.getAttribute('for-column');
      console.log(`${parseInt(columnIndex) === this._activeColumn ? '[A]' : ''}${columnIndex}::${target.renderedItemCount} ${(this.active||{label:'NULL'}).label}`)
      if (parseInt(columnIndex) === this._activeColumn) {
        this._visibleItemCount = target.renderedItemCount;
      }
    },

    _animateColumnHeight(nextItemCount, lastItemCount) {
      const itemHeight = parseInt(this.getComputedStyleValue('--px-context-browser-item-height') || '30px');
      const nextHeight = this._getNextColumnHeight(nextItemCount, itemHeight);
      const itemsEl = Polymer.dom(this.root).querySelector('#items');
      itemsEl.style.minHeight = nextHeight + 'px';
    },

    _getNextColumnHeight(nextItemCount, itemHeight) {
      if (nextItemCount === 0) {
        return 173; // MAGIC NUMBER: Height of the animation lines
      }
      if (nextItemCount > 10) {
        return itemHeight*10;
      }
      return itemHeight*nextItemCount;
    },

    _isHeaderActive(columns, activeColumn) {
      return (typeof columns === 'object' && typeof activeColumn === 'number' && columns[activeColumn] && columns[activeColumn].path.length > 0);
    }
  });

  class ColumnAnimator {
    constructor({itemHeight, headerHeight, borderSize}) {
      this.itemHeight = itemHeight;
      this.headerHeight = headerHeight;
      this.borderSize = borderSize;

      this._animationQueue = [];
      this._currentAnimation = null;
    }

    add(options) {
      const animation = this._createAnimation(options);
      this.addToQueue(animation);
      return animation;
    }

    addToQueue(animation) {
      this._animationQueue.push(animation);
      this._runAnimations();
    }

    _runAnimations() {
      if (this._currentAnimation) return;
      this._currentAnimation = this._animationQueue.shift();
      this._currentAnimation().then(() => {
        this._currentAnimation = null;
        if (this._animationQueue.length !== 0) this._runAnimations(this._animationQueue);
      });
    }

    _createAnimation({outEl, inEl, headerEl, panelEl, outItemCount, inItemCount, outHasHeader, inHasHeader, isMovingDown}) {
      const animations = {};

      // Animate header in/out
      const headerSlidingIn = (!outHasHeader && inHasHeader);
      const headerSlidingOut = (outHasHeader && !inHasHeader);
      if (headerSlidingIn) {
        animations.header = this._generateAnimation(headerEl, {
          animate: ColumnAnimator.fadeIn,
          before: (el) => {
            el.setAttribute('active', '')
          }
        });
      }
      if (headerSlidingOut) {
        animations.header = this._generateAnimation(headerEl, {
          animate: (el, duration) => ColumnAnimator.popOut(el, '0px', `-${this.headerHeight}px`, duration),
          after: (el) => {
            el.removeAttribute('active')
          }
        });
      }

      // Animate columns in/out
      animations.out = this._generateAnimation(outEl, {
        animate: isMovingDown ? ColumnAnimator.fadeOutLeft : ColumnAnimator.fadeOutRight,
        after: (el) => el.classList.remove('column--active')
      });
      animations.in = this._generateAnimation(inEl, {
        animate: (el, duration) => {
          if (headerSlidingOut) {
            return ColumnAnimator.fadeInLeftFromTop(el, duration, `-${this.headerHeight}px`);
          }
          if (isMovingDown) {
            return ColumnAnimator.fadeInRight(el, duration);
          }
          return ColumnAnimator.fadeInLeft(el, duration);
        },
        before: (el) => {
          el.classList.add('column--active')
        }
      });

      return () => Promise.all([animations.in(), animations.out(), animations.header ? animations.header() : Promise.resolve()]);
    }

    _generateAnimation(el, {animate, before, after}) {
      return () => {
        if (typeof before === 'function') {
          before.call(this, el);
        }
        return animate.call(this, el, 250).finished.then((a) => {
          if (typeof after === 'function') {
            after.call(this, el);
          }
          return Promise.resolve(a);
        });
      };
    }

    static fadeInRight(el, duration) {
      const keyframes = [
        { transform: 'translateX(-100%)', opacity: '0' },
        { transform: 'none', opacity: '1' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static fadeOutRight(el, duration) {
      const keyframes = [
        { transform: 'none', opacity: '1' },
        { transform: 'translateX(-100%)', opacity: '0' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static fadeInLeft(el, duration) {
      const keyframes = [
        { transform: 'translateX(100%)', opacity: '0' },
        { transform: 'none', opacity: '1' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static fadeInLeftFromTop(el, duration, topPosition) {
      const keyframes = [
        { transform: `translate(100%, ${topPosition})`, opacity: '0' },
        { transform: 'none', opacity: '1' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static fadeOutLeft(el, duration) {
      const keyframes = [
        { transform: 'none', opacity: '1' },
        { transform: 'translateX(100%)', opacity: '0' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static scaleHeight(el, startHeight, endHeight, duration) {
      const keyframes = [
        { minHeight: startHeight },
        { minHeight: endHeight }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static slideInDown(el, duration) {
      const keyframes = [
        { transform: 'translateY(-100%)' },
        { transform: 'none' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static slideOutUp(el, duration) {
      const keyframes = [
        { transform: 'none' },
        { transform: 'translateY(-100%)' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static fadeIn(el, duration) {
      const keyframes = [
        { opacity: '0' },
        { opacity: '1' }
      ];
      return el.animate(keyframes, { duration: duration });
    }

    static popOut(el, startMarginBottom, endMarginBottom, duration) {
      const keyframes = [
        { opacity: '1', marginBottom: startMarginBottom },
        { opacity: '0', marginBottom: endMarginBottom }
      ];
      return el.animate(keyframes, { duration: duration });
    }
  };
})();
</script>
